---
layout: post
title : "COFO::Cofo Round 838"
subtitle: "cofo round"
type: "codeforce div 2"
ps: true
cofo: true
round: true
text: true
author: "beenpow"
post-header: true
header-img: "https://marianblogt.nl/wp-content/uploads/2019/01/thelearningcurve-1024x713.jpg"
order: 1
date: "2022-12-16"
---

# COFO::Cofo Round #838
- [Link : COFO::Cofo round 838)](https://codeforces.com/contest/1762)
- solved : 
  - A : 00:08
  - B : 00:35
  - C :
  - rank : 4498
  - score : 1376

## Problem A : Divide and Conquer

- level : not decided yey
- tag : greedy, math, number theory

### point
- Find the minimum number of operations to make sum of the array as even
  - Operation : pick one value from array and make it half

### Design
- There will be lots of solutions for this problem
- But easy way to do it is that brute force
- Doing 'make it half' for one value repeatedly until the sum of the array is even is one of the solutions

#### Big O(time)
- O(N)

### Code

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define sz(x) (int)x.size()
#define all(x) x.begin(), x.end()
#define rep(i, a, b) for(int i = (a); i <(b); i++)
#define r_rep(i, a, b) for(int i = (a); i >(b); i--)
typedef long long ll;
using namespace std;
const int MAXN = 1e5 + 9;

int n;
int a[59];
int solve() {
    cin >> n;
    int sum = 0, ans = 1e9;
    rep(i, 0, n) {
        cin >> a[i];
        sum += a[i];
    }
    if (sum %2 == 0) return 0;
    
    rep(i, 0, n) {
        int x = a[i], psum = sum, cnt = 0;
        while(x > 0 && psum %2) {
            psum -= x;
            x /= 2;
            psum += x;
            cnt++;
        }
        if (psum %2 == 0) ans = min(ans, cnt);
    }
    return ans;
}
int main(){
    int t; cin >> t;
    while(t--)
    cout << solve() <<'\n';
    return 0;
}

```

## Problem B : Make Array Good

- level : not decided yes
- tag : constructive algorithms, implementation, number theory, sortings

### Point
- construct a sequence of at most n operations that will make a good
  - An array b of m positive integers is good if for all pairs i and j (1 <= i, j <= m) is divisible by min(bi, bj)

### Design
- To make the array good, all members should be someone's divisor and multiple
- To achieve this in easy way, we first need to sort the array to clear our mind
- Now we iterate from smallest number to largest number
  - Let's say current index of the array is i
  - Now, we need to make a[i] % a[i-1] = 0
  - We only need at most one operation to achieve this, since (a[i-1] < a[i] holds


#### Big O(time)
- O(NlogN)

### Code

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define sz(x) (int)x.size()
#define all(x) x.begin(), x.end()
#define rep(i, a, b) for(int i = (a); i <(b); i++)
#define r_rep(i, a, b) for(int i = (a); i >(b); i--)
typedef long long ll;
using namespace std;
const int MAXN = 1e5 + 9;

int n;
pair<ll, int> a[MAXN];
void solve() {
    cin >> n;
    rep(i, 0, n) {
        cin >> a[i].fi;
        a[i].se = i + 1;
    }
    sort(a, a + n);
    
    vector<pair<int,int> > ans;
    ll prev = 1;
    rep(i, 0, n) {
        ll q = a[i].fi / prev, r = a[i].fi % prev;
        if (r == 0) {
            prev = a[i].fi;
            continue;
        }
        
        ll add = prev - r;
        ans.push_back({a[i].se, add});
        
        prev = a[i].fi + add;
    }
    cout << sz(ans) << '\n';
    rep(i, 0, sz(ans)) {
        cout << ans[i].fi << " " << ans[i].se << '\n';
    }
}
int main(){
    int t; cin >> t; while(t--)
        solve();
    return 0;
}
```

## Problem C : Binary Strings are Fun

- level : not yet decided
- tag : combinatorics, fft, math, meet-in-the-middle

### Point
- Find the sum of the number of good extensions over all prefixes of s

### Design


#### Big O(time)
- O(N)

### Code

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define sz(x) (int)x.size()
#define all(x) x.begin(), x.end()
#define rep(i, a, b) for(int i = (a); i <(b); i++)
#define r_rep(i, a, b) for(int i = (a); i >(b); i--)
typedef long long ll;
using namespace std;
const int MAXN = 2e5 + 9;
const ll MOD = 998244353;


int n;
string s;

void solve() {
    cin >> n >> s;
    s = ' '  + s;
    
    ll cur = 1, ans = 0;
    rep(i, 1, n + 1) {
        if (s[i-1] == s[i]) {
            cur = (cur * 2) % MOD;
        } else
            cur = 1;
        ans = (ans + cur) % MOD;
    }
    cout << ans << '\n';
}

int main(){
    int t; cin >> t; while(t--)
        solve();
    return 0;
}
```
